# 4.2 隱式序列

:::details INFO
譯者：[DuKle3](https://github.com/DuKle3)

來源：[4.2Implicit Sequences](https://www.composingprograms.com/pages/42-implicit-sequences.html)

對應：HW04、Disc05、Lab07
:::

一個序列（sequence）不一定要把每個元素顯式存儲在計算機的內存中。換句話說，我們可以建立一個對象（object），它提供對某個序列的訪問，而無需事先計算每個元素的值。
取而代之，我們只在有需要的時候才計算元素

這個想法的一個例子為在第 2 章所介紹的 `range` 容器（container）類型，`range` 表示連續、有範圍的整數序列，然而，該序列的每個元素並不是顯式儲存在內存中的。
相反，當從 `range` 訪問某個元素時，才會進行計算來求得其值。因此，我們可以在不需要很多內存來表示非常大範圍的整數。只有端點會被儲存為 `range` 對象的一部份。

```python
>>> r = range(10000,1000000000)
>>> r[45006230]
45016230
```

在這個例子中，當創建 `range` 實例時，並沒有存儲此範圍內的 999,990,000 整數。反之，`range` 對像將第一個元素 10,000 添加到索引 45,006,230 來得出元素 45,016,230。按需要來計算值，而不是從現有的表示中去檢索他們，
這是惰性計算（Lazy computation）的一個範例。在計算機科學中，惰性計算指任何延遲計算，直到需要該值的程序。
> 譯者注：惰性計算是這一整篇的重點

## 4.2.1 迭代器
Python 和許多其他編程語言都提供了一種統一的方法來按照順序地處理容器內的元素，稱為迭代器（iterators）迭代器是一種對象，提供對值逐一順序訪問的功能。
迭代器抽象有兩個組件：

- 檢索下一個元素的機制
- 到達序列末尾並且沒有剩餘元素，發出信號的機制

對於任何容器，例如 `list` 或 `range`，都可以通過調用內置的 `iter` 函數來獲取迭代器。使用內置的 `next` 函數來訪問迭代器的內容。

```python
>>> primes = [2, 3, 5, 7]
>>> type(primes)
<class 'list'>
>>> iterator = iter(primes)
>>> type(iterator)
<class 'list-iterator'>
>>> next(iterator)
2
>>> next(iterator)
3
>>> next(iterator)
5
```
在 Python 中表示沒有更多可用值的方式是在調用 `next` 時引發 `StopIteration` 異常。可以使用 `try` 語句來處理此錯誤。

```python
>>> next(iterator)
7
>>> next(iterator)
Traceback (most recent call las):
  File "<stdin>", line 1, in <module>
StopIteration

>>> try:
        next(iterator)
    except StopIteration:
        print('No more values')
No more values
```
迭代器保持本地狀態（local state）來表示其在序列中的位置。每次調用 `next` 時，該位置都會前進。
兩個單獨的迭代器可以跟踪同一序列中的兩個不同位置。但是，兩個變量如果指向同一迭代器，它們會共享相同的值。

```python
>>> r = range(3, 13)
>>> s = iter(r)  # r 的第一個迭代器
>>> next(s)
3
>>> next(s)
4
>>> t = iter(r)  # r 的第二個迭代器
>>> next(t)
3
>>> next(t)
4
>>> u = t        # u 綁定到 r 的第二個迭代器
>>> next(u)
5
>>> next(u)
6
```
推進第二個迭代器不會影響第一個迭代器。由於第一個迭代器最後返回的值是 4，下一次返回 5。另一方面，第二個迭代器的位置會下一次返回 7。
```python
>>> next(s)
5
>>> next(t)
7
```
在迭代器上調用 `iter` 將返回該迭代器，而不是其副本。
Python 中包含此行為，以便程序員可以對某個值調用 `iter` 來獲取迭代器，而不必擔心它是迭代器還是容器。
> 譯者注：和 `list` 不同！
```python
>>> v = iter(t)  # v 綁定到 r 的第二個迭代器
>>> next(v)      # u, v, t 都為 r 的第二個迭代器
8
>>> next(u)
9
>>> next(t)
10
```
迭代器的有用性源於迭代器的基礎數據序列可能不會在內存中以顯式方式表示。

迭代器提供了一種機制，可以逐個考慮一系列的值，但不必同時存儲所有這些元素。

相反，當從迭代器請求下一個元素時，該元素可以按需求計算，而不是從現有的內存中檢索。

範圍（range）能夠懶惰地計算序列的元素，因為所代表的序列是統一的，並且任何元素都可以從範圍的起始和結束端點輕鬆計算得出。
迭代器允許對更廣泛的基礎連續數據集進行懶惰生成，因為它們不需要提供對基礎系列的任意元素的訪問。

相反，迭代器只需要按順序計算系列的下一個元素，每次請求另一個元素時進行計算。
雖然不如訪問序列的任意元素（稱為隨機訪問）靈活，但對於數據處理應用程序來說，對連續數據的順序訪問通常是足夠的。

## 4.2.2 可迭代性

任何可以產生迭代器的值都稱為可迭代值（iterable vallue）。
在 Python 中，可迭代值是任何可以傳遞給內置 `iter` 函數的值。
可迭代對象包括：

- **序列值**：例如字符串（string）和元組（tuples）

- **容器**：例如集合（sets）和字典（dictionaries）

迭代器也是可迭代的，因為它們可以傳遞給 `iter` 函數。

即使是無序集合（例如字典），在生成迭代器時也必須定義其內容的順序。
字典和集合是無序的，因為程序員無法控制迭代的順序，但 Python 確實在其規範中保證了有關其順序的某些屬性。
> 譯者注：現在 Python 3.6+ 版本，字典的順序是加入字典時的順序；在 Python 3.5 和之前的版本，字典是無順序的

```python
>>> d = {'one': 1, 'two': 2, 'three': 3}
>>> d
{'one': 1, 'three': 3, 'two': 2}
>>> k = iter(d)
>>> next(k)
'one'
>>> next(k)
'three'
>>> v = iter(d.values())
>>> next(v)
1
>>> next(v)
3
```

如果字典由於添加或刪除鍵（key）而導致其結構發生變化，則所有迭代器都會失效，
並且未來的迭代器可能會對其內容順序進行任意更改。另一方面，更改現有鍵的值不會更改內容的順序或使迭代器無效。

## 4.2.3 內置迭代器

有幾個內置函數將可迭代值作為參數，並返回迭代器。這些函數廣泛用於惰性序列處理

`map` 函數是惰性的：調用它時並不會執行計算，直到返回的迭代器被 `next` 調用

相反，會創建一個迭代器對象，如果使用 `next` 查詢，
該迭代器對象可以返回結果。我們可以在下面的示例中觀察到這一事實，其中對 `print` 的調用被延遲，直到從 `doubled` 迭代器請求相應的元素為止。

```python
>>> def double_and_print(x):
        print('***', x, '=>', 2*x, '***')
        return 2*x
>>> s = range(3, 7)
>>> doubled = map(double_and_print, s)  # double_and_print 未被調用
>>> next(doubled)                       # double_and_print 調用一次
*** 3 => 6 ***
6
>>> next(doubled)                       # double_and_print 再次調用
*** 4 => 8 ***
8
>>> list(doubled)                       # double_and_print 調用兩次
*** 5 => 10 ***
*** 6 => 12 ***
[10, 12]
```

`filter` 函數返回一個迭代器， `zip` 和 `reversed` 函數也返回迭代器。

## 4.2.4 For 語句

Python 中的 `for` 語句是對迭代器進行操作。
如果對象具有返回迭代器的 `__iter__` 方法（method），則表示對象是可迭代的。

可迭代對象可以是 `for` 語句標題中 `<expression>` 的值：
```python
for <name> in <expression>:
    <suite>
```

執行 `for` 語句，Python 會評估標頭（header）`<expression>`，它必須為可迭代的值。然後，對該值調用 `__iter__` 方法。

在觸發 `StopIteration` 異常之前，Python 會重複調用該迭代器上的 `__next__` 方法，並將結果綁定到 `for` 語句中的 `<name>`。然後，執行`<suite>`。

```python
>>> counts = [1, 2, 3]
>>> for item in counts:
        print(item)
1
2
3
```
在上面的例子中， `counts` 列表在對其調用 `__iter__()` 方法之後返回一個迭代器。 `for` 語句接著重複地調用迭代器的 `__next__()` 方法，並將其值和 `item` 綁定。
這個過程重複至迭代器觸發 `StopIteration` ，此時 for 語句的執行結束。

有了上述迭代器的知識，現在我們就可以用 `while`、賦值、 `try` 語句來實現 `for` 語句的執行規則。
```python
>>> items = counts.__iter__()
>>> try:
        while True:
             item = items.__next__()
             print(item)
    except StopIteration:
        pass
1
2
3
```
以上例子，通過調用 `counts` 的 `__iter__` 方法返回的迭代器綁定到一個名稱項（`items`），
以便可以依次查詢每個元素。 `StopIteration` 異常的處理子句不執行任何操作，但處理異常提供了退出 while 循環的控制機制。

要在 `for` 循環中使用迭代器，迭代器還必須具有 `__iter__` 方法。

迭代器類型 [Python 文檔](http://docs.python.org/3/library/stdtypes.html#iterator-types) 的部分，建議迭代器有一個返回迭代器本身的 `__iter__` 方法，這樣所有的迭代器都是可迭代的。

## 4.2.5 生成器和 Yield 語句

上面的 Letters 和 Positives（正整數和字符）對象要求我們引入一個新的字段（field）`self.current` 到我們的對象中，以跟踪通過序列的進度。
對於像上面所示的簡單序列，這可以很容易地完成。然而，對於複雜的序列來說， `__next__` 方法在計算中保存其位置可能相當困難。
生成器（Generators）使我們能夠通過利用 Python 解析器（Interpreter）的功能來定義更複雜的迭代。

生成器是由一種特殊類型的函數 **生成器函數** 返回的迭代器。
生成器函數與常規函數不同之處在於，它們在其主體內不包含 `return` 語句，而是使用 `yield` 語句來返回一系列元素。

生成器不使用對象的屬性來跟踪它們在序列中的進度。
相反，它們控制生成器函數的執行，在每次調用生成器的 `__next__` 方法時執行，直到下一個 `yield` 語句被執行為止。使用生成器函數可以更簡潔地實現 `Letters` 迭代器。

```python
>>> def letters_generator():
        current = 'a'
        while current <= 'd':
            yield current
            current = chr(ord(current) + 1)

>>> for letter in letters_generator():
        print(letter)
a
b
c
d
```
即使我們從未明確定義過 `__iter__` 或 `__next__` 方法， `yield` 語句表明我們正在定義一個生成器函數。
當調用時，生成器函數不返回特定的返回值，而是返回一個生成器（一種迭代器類型），該生成器本身可以返回所產出（yields）的值。

生成器對象具有 `__iter__` 和 `__next__` 方法，每次調用 `__next__` 方法都會從之前離開的地方繼續執行生成器函數，直到另一個 `yield` 語句被執行為止。

當第一次調用 `__next__` 時，程序會執行 `letters_generator` 函數的語句，直到遇到 `yield` 語句。然後，它暫停並返回 `current `的值。
 `yield `語句不會銷毀新建的環境，而是保留它供以後使用。
 
當再次調用 `__next__` 時，執行會從上次離開的地方繼續。 `current` 的值以及 `letters_generator` 作用域內的任何其他綁定名稱的值在多次調用 `__next__` 之下都會保留。

- 我們可以通過手動調用 `__next__()` 來遍歷生成器：
```python
>>> letters = letters_generator()
>>> type(letters)
<class 'generator'>
>>> letters.__next__()
'a'
>>> letters.__next__()
'b'
>>> letters.__next__()
'c'
>>> letters.__next__()
'd'
>>> letters.__next__()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```
生成器在第一次調用 `__next__` 之前，不會執行任何在生成器函數內的語句。生成器會觸發 `StopIteration` 異常當它遍歷完生成器函數中定義的範圍後。

## 4.2.6 可迭代接口

如果對一個對象調用其 `__iter__` 方法會返回一個迭代器，則稱為可迭代的（iterable），
可迭代值表示數據的集合，它們提供了一種可能產生多個迭代器的固定表示。

例如，下面的 `Letters` 類的實例表示連續字母的序列。每次調用 `__iter__` 方法時，都會構造一個新的 `LetterIter` 實例，該實例允許順序訪問序列的內容。
> 譯者注：這裡沒有 `LetterIter` 的實現，就把他當作可迭代的值
```python
>>> class Letters:
        def __init__(self, start='a', end='e'):
            self.start = start
            self.end = end
        def __iter__(self):
            return LetterIter(self.start, self.end)
```

內置 `iter` 函數在其參數上調用 `__iter__` 方法。在下面的表達式序列中，從同一可迭代序列所衍生的兩個迭代器獨立地按順序產生字母。

```python
>>> b_to_k = Letters('b', 'k')
>>> first_iterator = b_to_k.__iter__()
>>> next(first_iterator)
'b'
>>> next(first_iterator)
'c'
>>> second_iterator = iter(b_to_k)
>>> second_iterator.__next__()
'b'
>>> first_iterator.__next__()
'd'
>>> first_iterator.__next__()
'e'
>>> second_iterator.__next__()
'c'
>>> second_iterator.__next__()
'd'
```

- `Letters` 實例 `b_to_k` 
- `LetterIter` 迭代器實例 `first_iterator` 和 `secondary_iterator` 

他們的不同之處在於，`Letters` 實例不會更改，而迭代器實例會隨著每次調用 `next`（或等效地，每次調用 `__next__` ）而更改。迭代器通過順序數據跟踪進度，而可迭代則代表數據本身。

Python 中的許多內置函數都採用可迭代參數並返回迭代器。
例如，前文所提到過的 `map` 函數接受一個函數和一個可迭代對象。它返回一個迭代器，該迭代器將函數參數應用於可迭代參數中的每個元素的結果。

```python
>>> caps = map(lambda x: x.upper(), b_to_k)
>>> next(caps)
'B'
>>> next(caps)
'C'
```

## 4.2.7 使用 Yield 創建可迭代對象

在 Python 中，迭代器只對底層數據系列進行一次遍歷。在遍歷一次之後，當調用 `__next__()` 時，
迭代器將引發 `StopIteration` 異常。許多應用程序需要多次對元素進行迭代。例如，我們必須多次遍歷列表，以列舉所有元素對。

```python
>>> def all_pairs(s):
        for item1 in s:
            for item2 in s:
                yield (item1, item2)
>>> list(all_pairs([1, 2, 3]))
[(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]
```

序列本身並不是迭代器，而是可迭代的對象。在 Python 中，可迭代的接口由一個單獨的方法 `__iter__` 組成，該方法返回一個迭代器。
 Python 中的內置序列類型在調用它們的 `__iter__` 方法時會返回新的迭代器實例。如果可迭代對象每次調用 `__iter__` 時返回一個新的迭代器實例，那麼它可以被多次迭代。

可以通過實現可迭代接口來定義新的可迭代類。例如，下面的可迭代 `LettersWithYield` 類，當每次調用 `__iter__` 時，都會返回一個新的字母迭代器。

```python
>>> class LettersWithYield:
        def __init__(self, start='a', end='e')
            self.start = start
            self.end = end
        def __iter__(self):
            next_letter = self.start
            while next_letter < self.end:
                yield next_letter
                next_letter = chr(ord(next_letter) + 1)
```
`__iter__` 方法是一個生成器函數；它返回一個生成器對象，該對像生成字母 “a” 到 “d” ，然後停止。每次我們調用此方法時，新的生成器都會開始重新遍歷順序數據。
```python
>>> letters = LettersWithYield()
>>> list(all_pairs(letters))[:5]
[('a', 'a'), ('a', 'b'), ('a', 'c'), ('a', 'd'), ('b', 'a')]
```
> 譯者注：在 Python 3.3 中，加入了 `yield from` 語句，可以在 [Lecture](https://www.youtube.com/watch?v=eIBV4fsxnjE&list=PL6BsET-8jgYXMKOdcoi0Hy_Gn4fuY_XzL&index=7) 或是 [Python 3.3 更新文檔](https://docs.python.org/3/whatsnew/3.3.html) 取得更多相關資訊。

## 4.2.8 生成器接口

Python 的迭代器接口是使用一個名為 `__next__` 的方法來定義的，該方法返回某個底層連續序列的下一個元素。
在調用 `__next__` 時，迭代器可以執行檢索或計算下一個元素。對 `__next__` 的調用會對迭代器進行變異性（mutating）更改：它們會推進迭代器的位置。
因此，對 `__next__` 的多次調用會返回底層序列的連續元素。當在調用 `__next__` 時引發 `StopIteration` 異常，表示已經達到了序列的末端。

下面的 `LetterIter` 類，可以從 `start` 字符迭代至 `end` （不包括 `end` ）。

其中， `self.next_letter` 儲存下一個字符，在調用 `__next__` 時會返回並計算新的 `next_letter`。
```python
>>> class LetterIter:
        """依照 ASCII 碼值順序迭代字符的迭代器。"""
        def __init__(self, start='a', end='e'):
            self.next_letter = start
            self.end = end
        def __next__(self):
            if self.next_letter == self.end:
                raise StopIteration
            letter = self.next_letter
            self.next_letter = chr(ord(letter)+1)
            return letter
```
我們可以利用這個 `LetterIter` 類，以下面兩種方式來獲取在序列中的字符。

- `__next__` 方法
- `next()` 內置函數（其實也是調用 `__next__` ）

```python
>>> letter_iter = LetterIter()
>>> letter_iter.__next__()
'a'
>>> letter_iter.__next__()
'b'
>>> next(letter_iter)
'c'
>>> letter_iter.__next__()
'd'
>>> letter_iter.__next__()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 12, in next
StopIteration
```

迭代器是可變異的：它們在前進時紀錄序列中的位置。當遍歷至末端，這個迭代器就用完了。
例如： `LetterIter` 實例只能迭代一次。直到 `__next__()` 方法觸發 `StopIteration` 異常。

通常，迭代器不會被重置；取而代之，會創建一個新實例來開始新的迭代。

迭代器也允許我們通過實現永遠不會觸發 `StopIteration` 異常的 `__next__` 方法來表示無限級數。
例如，下面的 `Positives` 類迭代無限正整數。

```python
>>> class Positives:
        def __init__(self):
            self.next_positive = 1;
        def __next__(self):
            result = self.next_positive
            self.next_positive += 1
            return result
>>> p = Positives()
>>> next(p)
1
>>> next(p)
2
>>> next(p)
3
```

## 4.2.9 Streams

TODO

> 譯者注：原文未完成

## 4.2.10 Python 流

流（Streams）提供了另一種隱式表示連續數據的方法。 `Stream` 是一個惰性計算的鏈表（linked-list）。
類似於第 2 章中的 `Link` 類， `Stream` 實例會對其第一個元素和其餘（rest）部分的請求做出響應。就像 Link 一樣， `Stream` 的其餘部分本身也是一個 `Stream` 。但與 `Link` 不同的是，
`Stream` 的其餘部分僅在查找時計算，而不是提前存儲。也就是說， `Stream` 的其餘部分是惰性計算的。

為了實現這種惰性評估， `Stream` 存儲了一個計算其餘部分的函數。
每次調用該函數時，其返回值都會被緩存為 `Stream` 的一部分，存儲在一個名為 `_rest` 的屬性中，該屬性以底線命名，表示其不應直接訪問。

可訪問的 `rest` 屬性是一個屬性方法，它會返回流的其餘部分。通過這種設計， `Stream` 存儲了如何計算其餘部分的方法，
而不是直接存儲實際的數據。

```python
>>> class Stream:
        """惰性計算的鏈表"""
        class empty:
            def __repr__(self):
                return 'Stream.empty'
        empty = empty()
        def __init__(self, first, compute_rest=lambda: empty):
            assert callable(compute_rest), 'compute_rest 必須為可調用'
            self.first = first
            self._compute_rest = compute_rest
        @property
        def rest(self):
            """返回 Stream 的其他部分（緩存部分），如果需要計算，則計算"""
            if self._compute_rest is not None:
                self._rest = self._compute_rest()
                self._compute_rest = None 
            return self._rest
        def __repr__(self):
            return 'Stream({0}, <...>)'.format(repr(self.first))
```

鍊錶是使用嵌套表達式定義的。例如，我們可以創建一個代表元素 1 然後 5 的 `Link`，如下所示：
```python
>>> r = Link(1, Link(2 + 3, Link(9)))
```

同樣，我們可以創建一個代表同一系列的 `Stream` 。在請求 `Stream` 的其餘部分之前， `Stream` 實際上不會計算第二個元素 5 。我們通過創建 `lambda` 函數來實現這種效果。
```python
s = Stream(1, lambda: Stream(2 + 3, lambda: Stream(9)))
```

這裡， 1 是 `Stream` 的第一個元素，後面的 `lambda` 表達式返回一個用於計算 `Stream` 的其餘部分的函數。

訪問鍊錶 r 和 `Stream` s 的元素的過程類似。然而， 5 是存儲在 r 中，而在 s 中，它是在第一次請求時根據需求通過加法計算的。

```python
>>> r.first
1
>>> s.first
1
>>> r.rest.first
5
>>> s.rest.first
5
>>> r.rest
Link(5, Link(9))
>>> s.rest
Stream(5, <...>)
```
r 的剩餘部分是一個兩元素鍊錶，而 s 的剩餘部分包含一個計算剩餘部分的函數；它將返回空流（empty stream）的可能性尚未被發現。

當創建 `Stream` 實例時，字段 `self._rest` 為 `None`，表示 `Stream` 的其餘部分尚未計算。

當通過點表達式請求 `rest` 屬性時，將調用 `rest` 屬性方法，該方法會觸發 `self._rest = self._compute_rest()` 的計算。
由於 `Stream` 中的緩存機制，`compute_rest` 函數僅被調用一次，然後被丟棄。

`compute_rest` 函數的基本屬性是它不帶參數，並且返回 `Stream` 或 `Stream.empty`。

惰性評估為我們提供了使用 `Stream` 表示無限連續數據集的能力。例如，我們可以表示從任意起始值開始的遞增整數序列。

```python
>>> def integer_stream(first):
        def compute_rest():
            return integer_stream(first+1)
        return Stream(first, compute_rest)
>>> positives = integer_stream(1)
>>> positives
Stream(1, <...>)
>>> positives.first
1
```
當第一次調用 `integer_stream` 時，它返回一個 `Stream` ，其第一個是序列中的第一個整數。然而， `integer_stream` 實際上是遞歸的，
因為該 `Stream` 的 `compute_rest` 再次調用 `integer_stream` ，並帶有遞增的參數。
我們說 `integer_stream` 是惰性的，因為只有在請求 `integer_stream` 的 `rest` 部分時才會對 `integer_stream` 進行遞歸調用。

```python
>>> positives.first
1
>>> positives.rest.first
2
>>> positives.rest.rest
Stream(3, <...>)
```

同樣身為高階函數並操作序列的函數 `map` 和 `filter` ，也適用於 `Stream` ，儘管它們的實現必須更改以延遲（惰性）應用其參數函數。

`map_stream` 映射一個函數到一個 `Stream` 上，這會產生一個新的 `Stream` ， 局部定義的 `compute_rest` 函數確保每當計算其餘（rest）部分時，
該函數都會映射到 `Stream` 的其餘（rest）部分。

```python
>>> def map_stream(fn, s):
        if s is Stream.empty:
            return s
        def compute_rest():
            return map_stream(fn, s.rest)
        return Stream(fn(s,first), compute_rest)
```

可以通過定義一個 `compute_rest` 函數來過濾 `Stream` ，該函數將過濾器函數（filter function）應用於 `Stream` 的其餘（rest）部分。
如果過濾器函數拒絕 `Stream` 的第一個元素，則立即計算其餘元素。由於 `filter_stream` 是遞歸的，因此可以多次計算其餘部分，直到找到有效的第一個元素。

```python
>>> def filter_stream(fn, s);
        if s is Stream.empty:
            return s
        def compute_rest():
            return filter_stream(fn, s.rest)
        if fn(s.first):
            return Stream(s.first, compute_rest)
        else:
            return compute_rest()
```

上述的 `map_stream` 和 `filter_stream` 函數展示了 `Stream` 處理中的常見模式：每當計算其餘（rest）部分時，
局部定義的 `compute_rest` 函數都會遞歸地將處理函數應用於 `Stream` 的其餘部分。

要檢查 `Stream` 的內容，我們可以將前面 k 個元素轉換為 Python 列表。
```python
>>> def first_k_as_list(s, k):
        fist_k = []
        while s is not Stream.empty and k > 0:
            first_k.append(s.first)
            s, k = s.rest, k - 1
        return first_k
```
這個簡單的函數可以讓我們驗證我們的 `map_stream` 實現，用一個簡單例子：把 3 到 7 取平方

```python
>>> s = integer_stream(3)            # 創建整數流
>>> s
Stream(3, <...>)
>>> m = map_stream(lambda x: x*x, s) # 把 fn, s 傳入 map_stream 來得到新的流
>>> m
Stream(9, <...>)
>>> first_k_as_list(m, 5)            # 檢查前五項
[9, 16, 25, 36, 49]
>>> s
Stream(3, <...>)
>>> m = map_stream(lambda x: x*x, s)
>>> m
Stream(9, <...>)
>>> first_k_as_list(m, 5)
[9, 16, 25, 36, 49]
```

我們可以使用我們的 `filter_stream` 函數，使用[埃拉托斯特尼篩法（sieve of Eratosthenes）](https://zh.wikipedia.org/zh-tw/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95)來定義一個質數數列。
這種方法會過濾一個整數流，將所有是其第一個元素的倍數的數字移除。透過連續使用每個質數來過濾，所有的合數將會從流中被移除。

```python
>>> def primes(pos_stream):
        def not_divible(x):
            return x % pos_stream.first != 0
        def compute_rest():
            primes(filter_stream(not_divible, pos_stream.rest)) 
        return Stream(pos_stream.first, compute_rest)
```

通過使用 `first_k_as_list` 來查看 `primes` stream 的前 7 個元素

```python
>>> prime_numbers = primes(integer_stream(2))
>>> first_k_as_list(prime_numbers, 7)
[2, 3, 5, 7, 11, 13, 17]
```

流與迭代器形成對比，因為它們可以多次傳遞給純函數並每次產生相同的結果。
通過將素（質）數流轉換為列表，它不會被「用完」。即流的前綴轉換為列表後， `prime_numbers` 的第一個元素仍然是2。

```python
>>> prime_numbers.first
2
```

正如鏈表為序列抽象提供了簡單的實現一樣，流提供了一個簡單的、功能性的遞歸數據結構，通過使用高階函數來實現惰性求值。
